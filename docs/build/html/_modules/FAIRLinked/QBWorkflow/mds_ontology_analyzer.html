

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FAIRLinked.QBWorkflow.mds_ontology_analyzer &mdash; FAIRLinked 0.3.0.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=d1e448af"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            FAIRLinked
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../FAIRLinked.html">FAIRLinked package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">FAIRLinked</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">FAIRLinked.QBWorkflow.mds_ontology_analyzer</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for FAIRLinked.QBWorkflow.mds_ontology_analyzer</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">rdflib</span> <span class="kn">import</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">Namespace</span><span class="p">,</span> <span class="n">URIRef</span><span class="p">,</span> <span class="n">RDF</span><span class="p">,</span> <span class="n">OWL</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">FAIRLinked.QBWorkflow.utility</span> <span class="kn">import</span> <span class="n">NAMESPACE_MAP</span><span class="p">,</span> <span class="n">LIGHT_COLORS</span><span class="p">,</span> <span class="n">CATEGORY_COLORS</span><span class="p">,</span> <span class="n">ONTO_CORE_CATEGORIES</span>

<span class="c1">###############################################################################</span>
<span class="c1"># Global Namespaces</span>
<span class="c1">###############################################################################</span>
<span class="n">MDS</span> <span class="o">=</span> <span class="n">Namespace</span><span class="p">(</span><span class="n">NAMESPACE_MAP</span><span class="p">[</span><span class="s1">&#39;mds&#39;</span><span class="p">])</span>
<span class="n">RDFS</span> <span class="o">=</span> <span class="n">Namespace</span><span class="p">(</span><span class="n">NAMESPACE_MAP</span><span class="p">[</span><span class="s1">&#39;rdfs&#39;</span><span class="p">])</span>
<span class="n">SKOS</span> <span class="o">=</span> <span class="n">Namespace</span><span class="p">(</span><span class="n">NAMESPACE_MAP</span><span class="p">[</span><span class="s1">&#39;skos&#39;</span><span class="p">])</span>


<span class="c1">###############################################################################</span>
<span class="c1"># Helper Functions</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="update_category_colors">
<a class="viewcode-back" href="../../../FAIRLinked.QBWorkflow.html#FAIRLinked.QBWorkflow.mds_ontology_analyzer.update_category_colors">[docs]</a>
<span class="k">def</span> <span class="nf">update_category_colors</span><span class="p">(</span><span class="n">categories</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates the global CATEGORY_COLORS dictionary with color assignments for each category.</span>
<span class="sd">    </span>
<span class="sd">    The function ensures that each category (in prefixed form e.g. &#39;mds:tool&#39;) is assigned </span>
<span class="sd">    a unique color from the LIGHT_COLORS palette, cycling through colors if needed.</span>
<span class="sd">    </span>
<span class="sd">    High-level logic:</span>
<span class="sd">    1. Clear existing color assignments</span>
<span class="sd">    2. Convert full URIs to prefixed form (e.g. &#39;http://...#tool&#39; -&gt; &#39;mds:tool&#39;) </span>
<span class="sd">    3. Assign colors from palette to each prefixed category</span>
<span class="sd">    4. Update ONTO_CORE_CATEGORIES with final set of categories</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        categories (Set[str]): Set of category URIs to assign colors to</span>
<span class="sd">                              (e.g. {&#39;http://...#tool&#39;, &#39;http://...#recipe&#39;})</span>
<span class="sd">    </span>
<span class="sd">    Global Effects:</span>
<span class="sd">        - Updates CATEGORY_COLORS with mappings like {&#39;mds:tool&#39;: &#39;FFE6E6&#39;, &#39;mds:recipe&#39;: &#39;E6FFE6&#39;}</span>
<span class="sd">        - Updates ONTO_CORE_CATEGORIES with prefixed category names</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">CATEGORY_COLORS</span><span class="p">,</span> <span class="n">ONTO_CORE_CATEGORIES</span>
    
    <span class="c1"># Clear existing mappings</span>
    <span class="n">CATEGORY_COLORS</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">LIGHT_COLORS</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="c1"># Convert categories to prefixed form (e.g. &#39;mds:tool&#39;)</span>
    <span class="n">prefixed_categories</span> <span class="o">=</span> <span class="p">{</span><span class="n">get_prefixed_name</span><span class="p">(</span><span class="n">category</span><span class="p">)</span> <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">}</span>
    
    <span class="c1"># Assign colors cycling through palette</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">category</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prefixed_categories</span><span class="p">):</span>
        <span class="n">color_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
        <span class="n">CATEGORY_COLORS</span><span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">color_idx</span><span class="p">]</span>

    <span class="c1"># Update core categories set</span>
    <span class="n">ONTO_CORE_CATEGORIES</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">ONTO_CORE_CATEGORIES</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">prefixed_categories</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_prefixed_name">
<a class="viewcode-back" href="../../../FAIRLinked.QBWorkflow.html#FAIRLinked.QBWorkflow.mds_ontology_analyzer.get_prefixed_name">[docs]</a>
<span class="k">def</span> <span class="nf">get_prefixed_name</span><span class="p">(</span><span class="n">uri</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">URIRef</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a full URI to its corresponding prefixed form using the global namespace mappings.</span>

<span class="sd">    Algorithm:</span>
<span class="sd">    1. Convert the URIRef to a string if needed.</span>
<span class="sd">    2. Iterate over NAMESPACE_MAP to find a prefix whose namespace is a prefix of the given URI.</span>
<span class="sd">    3. If found, return prefix:LocalName. Otherwise, return the original URI string.</span>

<span class="sd">    Args:</span>
<span class="sd">        uri (Union[str, URIRef]): The URI to convert.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: Prefixed form of the URI (e.g. &#39;mds:SampleSize&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">ns</span> <span class="ow">in</span> <span class="n">NAMESPACE_MAP</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ns</span><span class="p">):</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">uri</span><span class="p">)[</span><span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="p">):]</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span></div>



<span class="c1">###############################################################################</span>
<span class="c1"># Core Ontology Analysis Functions</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="find_leaf_nodes">
<a class="viewcode-back" href="../../../FAIRLinked.QBWorkflow.html#FAIRLinked.QBWorkflow.mds_ontology_analyzer.find_leaf_nodes">[docs]</a>
<span class="k">def</span> <span class="nf">find_leaf_nodes</span><span class="p">(</span><span class="n">lowest_level_ontology_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">URIRef</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies leaf nodes in the lowest-level ontology. Leaf nodes are classes that do not serve </span>
<span class="sd">    as a superclass of any other class within the MDS namespace.</span>

<span class="sd">    Algorithm:</span>
<span class="sd">    1. Parse the lowest-level ontology and build an RDF graph.</span>
<span class="sd">    2. Gather all classes (subjects of RDFS.subClassOf) and their superclasses.</span>
<span class="sd">    3. Classes that never appear as an RDFS.subClassOf object are considered leaf nodes.</span>

<span class="sd">    Time Complexity:</span>
<span class="sd">    O(N + E) where N is the number of classes and E the number of subclass relations.</span>

<span class="sd">    Space Complexity:</span>
<span class="sd">    O(N) for storing classes and relationships.</span>

<span class="sd">    Args:</span>
<span class="sd">        lowest_level_ontology_path (str): Path to the low-level ontology (.ttl file).</span>

<span class="sd">    Returns:</span>
<span class="sd">        Set[URIRef]: A set of URIs representing leaf classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">lowest_level_ontology_path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;ttl&#39;</span><span class="p">)</span>

    <span class="c1"># Collect MDS superclasses</span>
    <span class="n">superclasses</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
        <span class="n">obj</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">objects</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">RDFS</span><span class="o">.</span><span class="n">subClassOf</span><span class="p">)</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">MDS</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="c1"># Collect MDS classes (appear as subjects of RDFS.subClassOf)</span>
    <span class="n">all_classes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
        <span class="n">subj</span> <span class="k">for</span> <span class="n">subj</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">subjects</span><span class="p">(</span><span class="n">RDFS</span><span class="o">.</span><span class="n">subClassOf</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">subj</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">MDS</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">all_classes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">superclasses</span><span class="p">)</span>

    <span class="c1"># Leaf nodes are classes not appearing as superclass of any other class</span>
    <span class="n">leaf_nodes</span> <span class="o">=</span> <span class="n">all_classes</span> <span class="o">-</span> <span class="n">superclasses</span>
    <span class="k">return</span> <span class="n">leaf_nodes</span></div>



<div class="viewcode-block" id="get_top_level_terms_from_combined">
<a class="viewcode-back" href="../../../FAIRLinked.QBWorkflow.html#FAIRLinked.QBWorkflow.mds_ontology_analyzer.get_top_level_terms_from_combined">[docs]</a>
<span class="k">def</span> <span class="nf">get_top_level_terms_from_combined</span><span class="p">(</span><span class="n">combined_ontology_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derives top-level categories directly from the combined ontology. This removes the need for a separate </span>
<span class="sd">    top-level ontology file.</span>

<span class="sd">    A top-level category is defined as a class that appears as a &#39;broader&#39; concept (object of SKOS.broader) </span>
<span class="sd">    but does not appear as a narrower concept for any other class within the MDS namespace. </span>
<span class="sd">    If no such classes are found, we consider classes with no broader relations as top-level.</span>

<span class="sd">    Algorithm:</span>
<span class="sd">    1. Parse the combined ontology.</span>
<span class="sd">    2. For all triples (narrower SKOS.broader broader), record narrower and broader classes.</span>
<span class="sd">    3. Top-level categories are those that appear as broader but never as narrower.</span>
<span class="sd">    4. If none found this way, fallback to classes that never appear as narrower at all.</span>

<span class="sd">    Time Complexity:</span>
<span class="sd">    O(N + E) where N is number of classes and E is number of SKOS.broader relationships.</span>

<span class="sd">    Space Complexity:</span>
<span class="sd">    O(N) for storing class sets and relationships.</span>

<span class="sd">    Args:</span>
<span class="sd">        combined_ontology_path (str): Path to the combined MDS ontology (.ttl file).</span>

<span class="sd">    Returns:</span>
<span class="sd">        Set[str]: A set of URIs for top-level category classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">combined_ontology_path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;ttl&#39;</span><span class="p">)</span>

    <span class="n">narrower_classes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">broader_classes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># Collect SKOS.broader relationships</span>
    <span class="k">for</span> <span class="n">subj</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">subjects</span><span class="p">(</span><span class="n">SKOS</span><span class="o">.</span><span class="n">broader</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">subj</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">MDS</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">objects</span><span class="p">(</span><span class="n">subj</span><span class="p">,</span> <span class="n">SKOS</span><span class="o">.</span><span class="n">broader</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">MDS</span><span class="p">)):</span>
                    <span class="n">narrower_classes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">subj</span><span class="p">))</span>
                    <span class="n">broader_classes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

    <span class="c1"># Top-level: appear as broader but not as narrower</span>
    <span class="n">top_level_categories</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">broader_classes</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">narrower_classes</span><span class="p">}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">top_level_categories</span><span class="p">:</span>
        <span class="c1"># Fallback: Consider classes that never appear as narrower at all</span>
        <span class="n">all_mds_classes</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">subjects</span><span class="p">(</span><span class="n">RDF</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">OWL</span><span class="o">.</span><span class="n">Class</span><span class="p">)</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">MDS</span><span class="p">))}</span>
        <span class="c1"># potential tops are those not in narrower_classes</span>
        <span class="n">potential_tops</span> <span class="o">=</span> <span class="n">all_mds_classes</span> <span class="o">-</span> <span class="n">narrower_classes</span>
        <span class="n">top_level_categories</span> <span class="o">=</span> <span class="n">potential_tops</span>

    <span class="k">return</span> <span class="n">top_level_categories</span></div>



<div class="viewcode-block" id="classify_leaf_nodes">
<a class="viewcode-back" href="../../../FAIRLinked.QBWorkflow.html#FAIRLinked.QBWorkflow.mds_ontology_analyzer.classify_leaf_nodes">[docs]</a>
<span class="k">def</span> <span class="nf">classify_leaf_nodes</span><span class="p">(</span><span class="n">combined_ontology_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                        <span class="n">leaf_nodes</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">URIRef</span><span class="p">],</span> 
                        <span class="n">top_level_terms</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classifies each leaf node into a top-level category by traversing upward along `rdfs:subClassOf` and </span>
<span class="sd">    `skos:broader` relationships until a known top-level category is found.</span>

<span class="sd">    Algorithm:</span>
<span class="sd">    1. Parse the combined ontology into a graph.</span>
<span class="sd">    2. For each leaf node, recursively follow `rdfs:subClassOf` and `skos:broader` upwards.</span>
<span class="sd">    3. If a top-level category is reached, classify the leaf under that category.</span>
<span class="sd">    4. If no top-level category is found, mark the leaf as missing.</span>

<span class="sd">    This uses memoization to avoid repeated traversals of the same class.</span>

<span class="sd">    Time Complexity:</span>
<span class="sd">    O(N + E) with memoization, where N is number of nodes and E is number of edges.</span>

<span class="sd">    Space Complexity:</span>
<span class="sd">    O(N) for memoization and classification structures.</span>

<span class="sd">    Args:</span>
<span class="sd">        combined_ontology_path (str): Path to the combined ontology (.ttl file).</span>
<span class="sd">        leaf_nodes (Set[URIRef]): Set of leaf node URIs identified from the low-level ontology.</span>
<span class="sd">        top_level_terms (Set[str]): Set of URIs representing top-level categories.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[Dict[str, List[str]], List[str]]:</span>
<span class="sd">            - Dictionary mapping top-level category URIs to a list of leaf node URIs.</span>
<span class="sd">            - List of URIs for leaf nodes that couldn&#39;t be mapped.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">combined_ontology_path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;ttl&#39;</span><span class="p">)</span>

    <span class="n">classification</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">memoization</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">missing_top_terms</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">trace_to_top</span><span class="p">(</span><span class="n">term_uri</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">visited</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">term_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">term_uri</span><span class="p">)</span>
        <span class="c1"># Check if current term is already known top-level</span>
        <span class="k">if</span> <span class="n">term_str</span> <span class="ow">in</span> <span class="n">top_level_terms</span><span class="p">:</span>
            <span class="n">memoization</span><span class="p">[</span><span class="n">term_uri</span><span class="p">]</span> <span class="o">=</span> <span class="n">term_uri</span>
            <span class="k">return</span> <span class="n">term_uri</span>

        <span class="c1"># Avoid cycles</span>
        <span class="k">if</span> <span class="n">term_uri</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">term_uri</span><span class="p">)</span>

        <span class="c1"># Traverse via rdfs:subClassOf</span>
        <span class="k">for</span> <span class="n">superclass</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">objects</span><span class="p">(</span><span class="n">term_uri</span><span class="p">,</span> <span class="n">RDFS</span><span class="o">.</span><span class="n">subClassOf</span><span class="p">):</span>
            <span class="n">top_term</span> <span class="o">=</span> <span class="n">trace_to_top</span><span class="p">(</span><span class="n">superclass</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">top_term</span><span class="p">:</span>
                <span class="n">memoization</span><span class="p">[</span><span class="n">term_uri</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_term</span>
                <span class="k">return</span> <span class="n">top_term</span>

        <span class="c1"># Traverse via skos:broader</span>
        <span class="k">for</span> <span class="n">broader_term</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">objects</span><span class="p">(</span><span class="n">term_uri</span><span class="p">,</span> <span class="n">SKOS</span><span class="o">.</span><span class="n">broader</span><span class="p">):</span>
            <span class="n">top_term</span> <span class="o">=</span> <span class="n">trace_to_top</span><span class="p">(</span><span class="n">broader_term</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">top_term</span><span class="p">:</span>
                <span class="n">memoization</span><span class="p">[</span><span class="n">term_uri</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_term</span>
                <span class="k">return</span> <span class="n">top_term</span>

        <span class="n">memoization</span><span class="p">[</span><span class="n">term_uri</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Classify each leaf node</span>
    <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaf_nodes</span><span class="p">:</span>
        <span class="n">top_term</span> <span class="o">=</span> <span class="n">trace_to_top</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">top_term</span><span class="p">:</span>
            <span class="n">top_term_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">top_term</span><span class="p">)</span>
            <span class="n">leaf_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
            <span class="n">classification</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">top_term_str</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leaf_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">missing_top_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">leaf</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">classification</span><span class="p">,</span> <span class="n">missing_top_terms</span></div>



<div class="viewcode-block" id="get_classification">
<a class="viewcode-back" href="../../../FAIRLinked.QBWorkflow.html#FAIRLinked.QBWorkflow.mds_ontology_analyzer.get_classification">[docs]</a>
<span class="k">def</span> <span class="nf">get_classification</span><span class="p">(</span><span class="n">lowest_level_ontology_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                       <span class="n">combined_ontology_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    High-level function that coordinates:</span>
<span class="sd">    1. Finding leaf nodes from the low-level ontology.</span>
<span class="sd">    2. Identifying top-level categories directly from the combined ontology.</span>
<span class="sd">    3. Classifying leaf nodes under these top-level categories.</span>
<span class="sd">    4. Updating category colors and converting URIs to prefixed forms.</span>

<span class="sd">    Args:</span>
<span class="sd">        lowest_level_ontology_path (str): Path to the lowest-level MDS ontology (.ttl file).</span>
<span class="sd">        combined_ontology_path (str): Path to the combined MDS ontology (.ttl file).</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[Dict[str, List[str]], List[str]]:</span>
<span class="sd">            - classification_prefixed: A dictionary with prefixed category URIs as keys and lists of prefixed leaf nodes as values.</span>
<span class="sd">            - missing_top_terms_prefixed: A list of prefixed URIs for terms that couldn&#39;t be mapped.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Step 1: Identify leaf nodes</span>
    <span class="n">leaf_nodes</span> <span class="o">=</span> <span class="n">find_leaf_nodes</span><span class="p">(</span><span class="n">lowest_level_ontology_path</span><span class="p">)</span>

    <span class="c1"># Step 2: Identify top-level categories from combined ontology</span>
    <span class="n">top_level_terms</span> <span class="o">=</span> <span class="n">get_top_level_terms_from_combined</span><span class="p">(</span><span class="n">combined_ontology_path</span><span class="p">)</span>

    <span class="c1"># Step 3: Classify leaf nodes</span>
    <span class="n">classification</span><span class="p">,</span> <span class="n">missing_top_terms</span> <span class="o">=</span> <span class="n">classify_leaf_nodes</span><span class="p">(</span><span class="n">combined_ontology_path</span><span class="p">,</span> <span class="n">leaf_nodes</span><span class="p">,</span> <span class="n">top_level_terms</span><span class="p">)</span>

    <span class="c1"># Step 4: Update category colors based on discovered categories</span>
    <span class="n">update_category_colors</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">classification</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="c1"># Convert URIs to prefixed names and strip prefixes from terms</span>
    <span class="n">classification_prefixed</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">category_uri</span><span class="p">,</span> <span class="n">leaf_uris</span> <span class="ow">in</span> <span class="n">classification</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">category_prefixed</span> <span class="o">=</span> <span class="n">get_prefixed_name</span><span class="p">(</span><span class="n">category_uri</span><span class="p">)</span>
        <span class="n">leaf_terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_prefixed_name</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">uri</span> <span class="ow">in</span> <span class="n">leaf_uris</span><span class="p">]</span>
        <span class="n">classification_prefixed</span><span class="p">[</span><span class="n">category_prefixed</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf_terms</span>
        
        <span class="c1"># Ensure category color exists</span>
        <span class="k">if</span> <span class="n">category_prefixed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">CATEGORY_COLORS</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: No color assigned for category </span><span class="si">{</span><span class="n">category_prefixed</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">missing_top_terms_prefixed</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_prefixed_name</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span> <span class="k">for</span> <span class="n">uri</span> <span class="ow">in</span> <span class="n">missing_top_terms</span><span class="p">]</span>
    <span class="c1"># print(classification_prefixed)</span>
    <span class="k">return</span> <span class="n">classification_prefixed</span><span class="p">,</span> <span class="n">missing_top_terms_prefixed</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Van D. Tran, Ritika Lamba, Balashanmuga Priyan Rajamohan, Gabriel Ponon, Kai Zheng, Benjamin Pierce, Quynh D. Tran, Ozan Dernek, Erika I. Barcelos, Roger H. French.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>